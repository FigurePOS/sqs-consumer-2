/// <reference types="node" />
import { EventEmitter } from "events";
import { ConsumerOptions, Events } from "./types";
export declare class Consumer extends EventEmitter {
    private readonly queueUrl;
    private readonly handleMessage;
    private readonly handleMessageBatch;
    private readonly handleMessageTimeout;
    private readonly attributeNames;
    private readonly messageAttributeNames;
    private readonly batchSize;
    private readonly visibilityTimeout;
    private readonly waitTimeSeconds;
    private readonly authenticationErrorTimeout;
    private readonly pollingWaitTimeMs;
    private readonly terminateVisibilityTimeout;
    private readonly heartbeatInterval;
    private readonly sqs;
    private pendingMessages;
    private stopped;
    private pollingStopped;
    private heartbeatTimeout;
    constructor(options: ConsumerOptions);
    private assertOptions;
    emit<T extends keyof Events>(event: T, ...args: Events[T]): boolean;
    on<T extends keyof Events>(event: T, listener: (...args: Events[T]) => void): this;
    once<T extends keyof Events>(event: T, listener: (...args: Events[T]) => void): this;
    get isRunning(): boolean;
    static create(options: ConsumerOptions): Consumer;
    start(): void;
    stop(): void;
    private pollSqs;
    private addToPendingMessages;
    private processNextPendingMessage;
    private processMessage;
    private processBatchPendingMessages;
    private processMessageBatch;
    private receiveMessage;
    private deleteMessage;
    private deleteMessages;
    private executeHandler;
    private executeBatchHandler;
    private changeVisibilityTimeout;
    private emitPendingStatus;
    private emitError;
    private changeVisibilityTimeoutOfBatch;
    private changeVisibilityTimeoutBatch;
    private startHeartbeat;
    private stopHeartbeat;
    private isBatchProcessing;
}
